=begin
#Daily API

#The Daily REST API offers the ability to manage the following:  - Overall Domain Configuration - Individual Room creation and config management  - Meeting token creation and validation - Recording and compositing management  - Meeting analytics - Logs and metrics - Real-time presence  Please reach out to help@daily.co if we can help with anything

The version of the OpenAPI document: 1.1.1
Contact: help@daily.co
Generated by: https://openapi-generator.tech
Generator version: 7.8.0

=end

require 'date'
require 'time'

module Daily
  class Properties
    # The room for which this token is valid. If `room_name` isn't set, the token is valid for all rooms in your domain. *You should always set `room_name` if you are using this token to control access to a meeting.
    attr_accessor :room_name

    # Kick this user out of the meeting at the time this meeting token expires. If either this property or `eject_after_elapsed` are set for the token, the room's `eject` properties are overridden.  _See an example in our [advanced security tutorial](https://www.daily.co/blog/add-advanced-security-features-to-video-chats-with-the-daily-api/)_.
    attr_accessor :eject_at_token_exp

    # Kick this user out of the meeting this many seconds after they join the meeting. If either this property or `eject_at_token_exp` are set for the token, the room's `eject` properties are overridden.  _See an example in our [advanced security tutorial](https://www.daily.co/blog/add-advanced-security-features-to-video-chats-with-the-daily-api/)_.
    attr_accessor :eject_after_elapsed

    # \"Not before\". This is a [unix timestamp](https://stackoverflow.com/questions/20822821/what-is-a-unix-timestamp-and-why-use-it) (seconds since the epoch.) Users cannot join a meeting in with this token before this time.
    attr_accessor :nbf

    # \"Expires\". This is a unix timestamp (seconds since the epoch.) Users cannot join a meeting with this token after this time.  Daily strongly recommends adding an `exp` value to all meeting tokens. Learn more in our Daily blog post: [Add advanced security to video chats with the Daily API](https://www.daily.co/blog/add-advanced-security-features-to-video-chats-with-the-daily-api/)
    attr_accessor :exp

    # The user has [meeting owner privileges](https://docs.daily.co/docs/controlling-who-joins-a-meeting#meeting-owner-privileges). For example, if the room is configured for `owner_only_broadcast` and used in a Daily Prebuilt call, this user can send video, and audio, and can screenshare.
    attr_accessor :is_owner

    # The user's name in this meeting. The name displays in the user interface when the user is muted or has turned off the camera, and in the chat window. This username is also saved in the meeting events log (meeting events are retrievable using the [analytics](/reference/rest-api/meetings) API methods.)
    attr_accessor :user_name

    # The user's ID for this meeting session. During a session, this ID is retrievable in the [`participants()`](/reference/daily-js/instance-methods/participants) method and [related participant events](/reference/daily-js/events/participant-events). Either during or after a session concludes, this ID is retrievable using the [/meetings](/reference/rest-api/meetings) REST API endpoint. You can use `user_id` to map between your user database and meeting events/attendance.  For domains configured for [HIPAA compliance](/guides/privacy-and-security/hipaa), if the `user_id` value is a [UUID](https://www.ietf.org/rfc/rfc4122.txt) (for example, `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`), then the UUID will be returned for the participant in the [`/meetings`](/reference/rest-api/meetings) REST API endpoint. Otherwise, the string `hipaa` will be returned in order to remove potential PHI. During a session, the provided `user_id` will always be returned through the `participants()` method and related events, regardless of the `user_id` value.  The `user_id` has a limit of 36 characters.
    attr_accessor :user_id

    # Sets whether or not the user is allowed to screen share. This setting applies for the duration of the meeting. If you're looking to dynamically control whether a user can screen share during a meeting, then use the [`permissions`](/reference/rest-api/meeting-tokens/config#permissions) token property.
    attr_accessor :enable_screenshare

    # Disable the default behavior of automatically turning on a participant's camera on a direct `join()` (i.e. without `startCamera()` first).
    attr_accessor :start_video_off

    # Disable the default behavior of automatically turning on a participant's microphone on a direct `join()` (i.e. without `startCamera()` first).
    attr_accessor :start_audio_off

    # Jump to [recording docs](/reference/rest-api/recordings).
    attr_accessor :enable_recording

    # Determines whether the participant using the meeting token enters a waiting room with a camera, mic, and browser check before joining a call. If this property is also set in the room or domain's configuration, the meeting token's configuration will take priority.  ⚠️ You must be using [Daily Prebuilt](https://daily.co/prebuilt) to use `enable_prejoin_ui`.
    attr_accessor :enable_prejoin_ui

    # Sets whether the participant sees a closed captions button in their Daily Prebuilt call tray. When the closed caption button is clicked, closed captions are displayed locally.  When set to `true`, a closed captions button appears in the call tray. When set to `false`, the closed captions button is hidden from the call tray.  Note: Transcription must be enabled for the room or users must have permission to start transcription for this feature to be enabled. View the [transcription guide](/guides/products/transcription) for more details.  ⚠️ You must be using [Daily Prebuilt](https://daily.co/blog/daily-prebuilt-video-chat) to use `enable_live_captions_ui`.
    attr_accessor :enable_live_captions_ui

    # Determines whether the participant using the meeting token can see the Recording button in Daily Prebuilt's UI, which can be found in the video call tray. If this value is `false`, the button will not be included in the tray. If it's `true`, the Recording button will be displayed.  This option is useful when only specific call participants should have recording permissions.   ⚠️ You must be using [Daily Prebuilt](https://daily.co/prebuilt) to use `enable_recording_ui`.
    attr_accessor :enable_recording_ui

    # Reduces the volume of log messages. This feature should be enabled when there are more than 200 participants in a meeting to help improve performance.  See our [guides for supporting large experiences](/guides/scaling-calls) for additional instruction.
    attr_accessor :enable_terse_logging

    # Start cloud recording when the user joins the room. This can be used to always record and archive meetings, for example in a customer support context.  Note: This requires the `enable_recording` property of the room or token to be set to `cloud`. If you want to automatically record calls with other recording modes, use `callObject.startRecording()` after `await callObject.join()` in your code.
    attr_accessor :start_cloud_recording

    # Options for use when `start_cloud_recording` is `true`. See [`startRecording`](/reference/daily-js/instance-methods/start-recording) for available options.  ⚠️ Specifying too many options may cause the token size to be very large. It is recommended to use token less than 2048 characters. For complex usecases, use the daily-js API.
    attr_accessor :start_cloud_recording_opts

    # Start transcription when an owner joins the room. This property can be used to always transcribe meetings once an owner joins.
    attr_accessor :auto_start_transcription

    # (For meetings that open in a separate browser tab.) When a user leaves a meeting using the button in the in-call menu bar, the browser tab closes. This can be a good way, especially on mobile, for users to be returned to a previous website flow after a call.
    attr_accessor :close_tab_on_exit

    # (For meetings that open in a separate browser tab.) When a user leaves a meeting using the button in the in-call menu bar, the browser loads this URL. A query string that includes a parameter of the form `recent-call=<domain>/<room>` is appended to the URL. On mobile, you can redirect to a deep link to bring a user back into your app.
    attr_accessor :redirect_on_meeting_exit

    # The default language of the [Daily prebuilt video call UI](https://docs.daily.co/docs/embed-the-daily-prebuilt-ui#daily-prebuilt-ui), for this room.   Setting the language at the token level will override any room or domain-level language settings you have.  Read more about [changing prebuilt UI language settings](https://help.daily.co/en/articles/4579930-changing-the-language-setting-of-the-prebuilt-ui).  `*` Norwegian `\"no\"` and Russian `\"ru\"` are only available in the new Daily Prebuilt.
    attr_accessor :lang

    attr_accessor :permissions

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'room_name' => :'room_name',
        :'eject_at_token_exp' => :'eject_at_token_exp',
        :'eject_after_elapsed' => :'eject_after_elapsed',
        :'nbf' => :'nbf',
        :'exp' => :'exp',
        :'is_owner' => :'is_owner',
        :'user_name' => :'user_name',
        :'user_id' => :'user_id',
        :'enable_screenshare' => :'enable_screenshare',
        :'start_video_off' => :'start_video_off',
        :'start_audio_off' => :'start_audio_off',
        :'enable_recording' => :'enable_recording',
        :'enable_prejoin_ui' => :'enable_prejoin_ui',
        :'enable_live_captions_ui' => :'enable_live_captions_ui',
        :'enable_recording_ui' => :'enable_recording_ui',
        :'enable_terse_logging' => :'enable_terse_logging',
        :'start_cloud_recording' => :'start_cloud_recording',
        :'start_cloud_recording_opts' => :'start_cloud_recording_opts',
        :'auto_start_transcription' => :'auto_start_transcription',
        :'close_tab_on_exit' => :'close_tab_on_exit',
        :'redirect_on_meeting_exit' => :'redirect_on_meeting_exit',
        :'lang' => :'lang',
        :'permissions' => :'permissions'
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'room_name' => :'String',
        :'eject_at_token_exp' => :'Boolean',
        :'eject_after_elapsed' => :'Integer',
        :'nbf' => :'Integer',
        :'exp' => :'Integer',
        :'is_owner' => :'Boolean',
        :'user_name' => :'String',
        :'user_id' => :'String',
        :'enable_screenshare' => :'Boolean',
        :'start_video_off' => :'Boolean',
        :'start_audio_off' => :'Boolean',
        :'enable_recording' => :'String',
        :'enable_prejoin_ui' => :'Boolean',
        :'enable_live_captions_ui' => :'Boolean',
        :'enable_recording_ui' => :'Boolean',
        :'enable_terse_logging' => :'Boolean',
        :'start_cloud_recording' => :'Boolean',
        :'start_cloud_recording_opts' => :'Object',
        :'auto_start_transcription' => :'Boolean',
        :'close_tab_on_exit' => :'Boolean',
        :'redirect_on_meeting_exit' => :'String',
        :'lang' => :'String',
        :'permissions' => :'Permissions'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `Daily::Properties` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `Daily::Properties`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'room_name')
        self.room_name = attributes[:'room_name']
      end

      if attributes.key?(:'eject_at_token_exp')
        self.eject_at_token_exp = attributes[:'eject_at_token_exp']
      else
        self.eject_at_token_exp = false
      end

      if attributes.key?(:'eject_after_elapsed')
        self.eject_after_elapsed = attributes[:'eject_after_elapsed']
      end

      if attributes.key?(:'nbf')
        self.nbf = attributes[:'nbf']
      end

      if attributes.key?(:'exp')
        self.exp = attributes[:'exp']
      end

      if attributes.key?(:'is_owner')
        self.is_owner = attributes[:'is_owner']
      else
        self.is_owner = false
      end

      if attributes.key?(:'user_name')
        self.user_name = attributes[:'user_name']
      end

      if attributes.key?(:'user_id')
        self.user_id = attributes[:'user_id']
      end

      if attributes.key?(:'enable_screenshare')
        self.enable_screenshare = attributes[:'enable_screenshare']
      else
        self.enable_screenshare = true
      end

      if attributes.key?(:'start_video_off')
        self.start_video_off = attributes[:'start_video_off']
      else
        self.start_video_off = false
      end

      if attributes.key?(:'start_audio_off')
        self.start_audio_off = attributes[:'start_audio_off']
      else
        self.start_audio_off = false
      end

      if attributes.key?(:'enable_recording')
        self.enable_recording = attributes[:'enable_recording']
      end

      if attributes.key?(:'enable_prejoin_ui')
        self.enable_prejoin_ui = attributes[:'enable_prejoin_ui']
      end

      if attributes.key?(:'enable_live_captions_ui')
        self.enable_live_captions_ui = attributes[:'enable_live_captions_ui']
      end

      if attributes.key?(:'enable_recording_ui')
        self.enable_recording_ui = attributes[:'enable_recording_ui']
      end

      if attributes.key?(:'enable_terse_logging')
        self.enable_terse_logging = attributes[:'enable_terse_logging']
      else
        self.enable_terse_logging = false
      end

      if attributes.key?(:'start_cloud_recording')
        self.start_cloud_recording = attributes[:'start_cloud_recording']
      else
        self.start_cloud_recording = false
      end

      if attributes.key?(:'start_cloud_recording_opts')
        self.start_cloud_recording_opts = attributes[:'start_cloud_recording_opts']
      end

      if attributes.key?(:'auto_start_transcription')
        self.auto_start_transcription = attributes[:'auto_start_transcription']
      else
        self.auto_start_transcription = false
      end

      if attributes.key?(:'close_tab_on_exit')
        self.close_tab_on_exit = attributes[:'close_tab_on_exit']
      else
        self.close_tab_on_exit = false
      end

      if attributes.key?(:'redirect_on_meeting_exit')
        self.redirect_on_meeting_exit = attributes[:'redirect_on_meeting_exit']
      end

      if attributes.key?(:'lang')
        self.lang = attributes[:'lang']
      else
        self.lang = 'en'
      end

      if attributes.key?(:'permissions')
        self.permissions = attributes[:'permissions']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      enable_recording_validator = EnumAttributeValidator.new('String', ["cloud", "local", "raw-tracks", "unknown_default_open_api"])
      return false unless enable_recording_validator.valid?(@enable_recording)
      lang_validator = EnumAttributeValidator.new('String', ["da", "de", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pt", "pt-BR", "pl", "ru", "sv", "tr", "user", "unknown_default_open_api"])
      return false unless lang_validator.valid?(@lang)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] enable_recording Object to be assigned
    def enable_recording=(enable_recording)
      validator = EnumAttributeValidator.new('String', ["cloud", "local", "raw-tracks", "unknown_default_open_api"])
      unless validator.valid?(enable_recording)
        fail ArgumentError, "invalid value for \"enable_recording\", must be one of #{validator.allowable_values}."
      end
      @enable_recording = enable_recording
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] lang Object to be assigned
    def lang=(lang)
      validator = EnumAttributeValidator.new('String', ["da", "de", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pt", "pt-BR", "pl", "ru", "sv", "tr", "user", "unknown_default_open_api"])
      unless validator.valid?(lang)
        fail ArgumentError, "invalid value for \"lang\", must be one of #{validator.allowable_values}."
      end
      @lang = lang
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          room_name == o.room_name &&
          eject_at_token_exp == o.eject_at_token_exp &&
          eject_after_elapsed == o.eject_after_elapsed &&
          nbf == o.nbf &&
          exp == o.exp &&
          is_owner == o.is_owner &&
          user_name == o.user_name &&
          user_id == o.user_id &&
          enable_screenshare == o.enable_screenshare &&
          start_video_off == o.start_video_off &&
          start_audio_off == o.start_audio_off &&
          enable_recording == o.enable_recording &&
          enable_prejoin_ui == o.enable_prejoin_ui &&
          enable_live_captions_ui == o.enable_live_captions_ui &&
          enable_recording_ui == o.enable_recording_ui &&
          enable_terse_logging == o.enable_terse_logging &&
          start_cloud_recording == o.start_cloud_recording &&
          start_cloud_recording_opts == o.start_cloud_recording_opts &&
          auto_start_transcription == o.auto_start_transcription &&
          close_tab_on_exit == o.close_tab_on_exit &&
          redirect_on_meeting_exit == o.redirect_on_meeting_exit &&
          lang == o.lang &&
          permissions == o.permissions
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [room_name, eject_at_token_exp, eject_after_elapsed, nbf, exp, is_owner, user_name, user_id, enable_screenshare, start_video_off, start_audio_off, enable_recording, enable_prejoin_ui, enable_live_captions_ui, enable_recording_ui, enable_terse_logging, start_cloud_recording, start_cloud_recording_opts, auto_start_transcription, close_tab_on_exit, redirect_on_meeting_exit, lang, permissions].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Daily.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
