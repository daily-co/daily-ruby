=begin
#Daily API

#The Daily REST API offers the ability to manage the following:  - Overall Domain Configuration - Individual Room creation and config management  - Meeting token creation and validation - Recording and compositing management  - Meeting analytics - Logs and metrics - Real-time presence  Please reach out to help@daily.co if we can help with anything

The version of the OpenAPI document: 1.1.1
Contact: help@daily.co
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 7.3.0

=end

require 'date'
require 'time'

module Daily
  class RoomProperties
    # \"Not before\". This is a [unix timestamp](https://stackoverflow.com/questions/20822821/what-is-a-unix-timestamp-and-why-use-it) (seconds since the epoch.) Users cannot join a meeting in this room before this time.
    attr_accessor :nbf

    # \"Expires\". This is a unix timestamp (seconds since the epoch.) Users cannot join a meeting in this room after this time.  More resources: - [Add advanced security to video chats with the Daily API](https://www.daily.co/blog/add-advanced-security-features-to-video-chats-with-the-daily-api/)
    attr_accessor :exp

    # How many people are allowed in a room at the same time.  ⚠️ [Contact us](https://www.daily.co/contact) if you need to set the limit above 200.
    attr_accessor :max_participants

    # Determines if [Daily Prebuilt](/guides/products/prebuilt) displays the People UI. When set to true, a People button in the call tray reveals a People tab in the call sidebar. The tab lists all participants, and next to each name indicates audio status and an option to pin the participant. When `enable_people_ui` is set to false, the button and tab are hidden.  ⚠️ Has no effect on custom calls built on the Daily [call object](/guides/products/call-object).
    attr_accessor :enable_people_ui

    # Sets whether the room can use [Daily Prebuilt](https://www.daily.co/prebuilt)'s Picture in Picture controls. When set to `true`, an additional button will be available in Daily Prebuilt's UI to toggle the Picture in Picture feature.  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :enable_pip_ui

    # Determines if [Daily Prebuilt](https://www.daily.co/prebuilt) displays the Emoji Reactions UI. When set to `true`, a Reactions button appears in the call tray. This button allows users to select and send a reaction into the call. When set to `false`, the Reactions button is hidden and the feature is disabled.  Usage: This feature is a good fit for meetings when a host or presenter would benefit from receiving nonverbal cues from the audience. It's also great to keep meetings fun.  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :enable_emoji_reactions

    # Sets whether the participants in the room can use [Daily Prebuilt](https://www.daily.co/prebuilt)'s hand raising controls. When set to `true`, an additional button will be available in Daily Prebuilt's UI to toggle a hand raise.  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :enable_hand_raising

    # Determines whether participants enter a waiting room with a camera, mic, and browser check before joining a call.  ⚠️ You must be using [Daily Prebuilt](https://daily.co/prebuilt) to use `enable_prejoin_ui`.
    attr_accessor :enable_prejoin_ui

    # Determines whether the network button, and the network panel it reveals on click, appears in this room.  ⚠️ You must be using [Daily Prebuilt](https://daily.co/prebuilt) to use `enable_network_ui`.
    attr_accessor :enable_network_ui

    # Determines whether Daily Prebuilt displays noise cancellation controls. When set to `true`, a participant can enable microphone noise cancellation during a Daily Prebuilt call. ⚠️ This flag only applies to [Daily Prebuilt](https://daily.co/prebuilt). It has no effect when building custom video applications with the Daily call object. To learn more about adding noise cancellation to a custom application, see the [`updateInputSettings()` docs](/reference/daily-js/instance-methods/update-input-settings).
    attr_accessor :enable_noise_cancellation_ui

    # Sets whether [Daily Prebuilt](https://www.daily.co/prebuilt)’s breakout rooms feature is enabled. When set to `true`, an owner in a Prebuilt call can create breakout rooms to divide participants into smaller, private groups.   ⚠️ You must be using [Daily Prebuilt](https://daily.co/blog/daily-prebuilt-video-chat) to use `enable_breakout_rooms`.  ⚠️ This property is in beta.
    attr_accessor :enable_breakout_rooms

    # Turns on a lobby experience for private rooms. A participant without a corresponding [meeting token](/reference/rest-api/meeting-tokens/config) can request to be admitted to the meeting with a \"knock\", and wait for the meeting owner to admit them.
    attr_accessor :enable_knocking

    # Sets whether users in a room can screen share during a session. This property cannot be changed after a session starts. For dynamic control over permissions, use the [`updateParticipant()`](/reference/daily-js/instance-methods/update-participant#permissions) method to control user permissions.
    attr_accessor :enable_screenshare

    # Determines whether Daily Prebuilt displays background blur controls. When set to `true`, a participant can enable blur during a Daily Prebuilt call.  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :enable_video_processing_ui

    # This property is one of [multiple ways to add chat to Daily video calls](https://www.daily.co/blog/three-ways-to-add-chat-to-your-video-calls-with-the-daily-api/).
    attr_accessor :enable_chat

    # Disable the default behavior of automatically turning on a participant's camera on a direct `join()` (i.e. without `startCamera()` first).
    attr_accessor :start_video_off

    # Disable the default behavior of automatically turning on a participant's microphone on a direct `join()` (i.e. without `startCamera()` first).
    attr_accessor :start_audio_off

    # In Daily Prebuilt, only the meeting owners will be able to turn on camera, unmute mic, and share screen.  See [setting up calls](https://docs.daily.co/docs/setting-up-calls).
    attr_accessor :owner_only_broadcast

    # Jump to [recording docs](/reference/rest-api/recordings).
    attr_accessor :enable_recording

    # If there's a meeting going on at room `exp` time, end the meeting by kicking everyone out. This behavior can be overridden by setting `eject` properties of a [meeting token](/reference/rest-api/meeting-tokens).
    attr_accessor :eject_at_room_exp

    # Eject a meeting participant this many seconds after the participant joins the meeting. You can use this is a default length limit to prevent long meetings. This can be overridden by setting `eject` properties of a [meeting token](/reference/rest-api/meeting-tokens).
    attr_accessor :eject_after_elapsed

    # Property that gives end users a richer chat experience. This includes:  * Emoji reactions to chat messages * Emoji picker in the chat input form * Ability to send a Giphy chat message  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :enable_advanced_chat

    # When enabled, non-owner users join a meeting with a hidden presence, meaning they won't appear as a named participant in the meeting and have no [participant events](https://docs.daily.co/reference/daily-js/events/participant-events) associated to them. Additionally, these participants can _only_ receive media tracks from owner participants.  Hidden participants can be tracked using the [`participantCounts()`](/reference/daily-js/instance-methods/participant-counts) method. Hidden participants do _not_ have entries in the [`participants()`](/reference/daily-js/instance-methods/participants) method return value.  When used with [Daily Prebuilt](/guides/products/prebuilt), hidden participants are included in the participant count available in the UI; however, are _not_ included in the People panel and can only read chat messages.  This property should be used to support hosting large meetings. See our [guide on interactive live streaming](/guides/scaling-calls/interactive-live-streaming-rtmp-output#interactive-live-streaming-up-to-100-000-participants) for additional instruction.
    attr_accessor :enable_hidden_participants

    # Configures a room to use multiple SFUs for a call's media. This feature enables calls to scale to large sizes and to reduce latency between participants. It is recommended specifically for interactive live streaming.  See our [guide for interactive live streaming](/guides/scaling-calls/interactive-live-streaming-rtmp-output#daily-prebuilt-configurations-to-support-100-000-participants) for additional instruction.
    attr_accessor :enable_mesh_sfu

    # Dictates the participant count after which room topology automatically switches from Peer-to-Peer (P2P) to Selective Forwarding Unit (SFU) mode, or vice versa.  For example, if `sfu_switchover` is set to `3` and the current network topology is P2P, the topology will switch to SFU mode when the _fourth_ participant joins the call. If the current topology is SFU, it will switch to P2P mode when the participant count decreases from `3` to `2`.  We recommend specifying an integer value for this property except for cases where you would like the room to switch to SFU mode as soon as the first participant joins. In this case, set `sfu_switchover` to `0.5`.  See our [guide about video call architecture](/guides/architecture-and-monitoring/intro-to-video-arch#the-architecture-of-a-room-p2p-vs-sfu-calls) for additional information.
    attr_accessor :sfu_switchover

    # Enables Daily Prebuilt to support group calls of up to 1,000 participants and [owner only broadcast](/reference/rest-api/rooms/config#owner_only_broadcast) calls of up to 100K participants.  When set to true, Daily Prebuilt will: - Automatically mute the local user on joining - Update grid view to show a maximum of 12 users in the grid at a time - Allow only 16 users to be unmuted at the same time. When more than 16 users are unmuted, the oldest active speaker will be automatically muted.  See our [guide on large real-time calls](/guides/scaling-calls/large-real-time-calls) for additional instruction.  ⚠️ This flag only applies to Daily Prebuilt. It has no effect when building custom video applications with the Daily call object.
    attr_accessor :experimental_optimize_large_calls

    # The default language of the [Daily prebuilt video call UI](/guides/products/prebuilt#daily-prebuilt-ui), for this room.  Setting the language at the room level will override any domain-level language settings you have.  Read more about [changing prebuilt UI language settings](https://help.daily.co/en/articles/4579930-changing-the-language-setting-of-the-prebuilt-ui).  `*` Norwegian `\"no\"` and Russian `\"ru\"` are only available in the new Daily Prebuilt.
    attr_accessor :lang

    # Sets a URL that will receive a webhook when a user joins a room. Default is NULL. Character limit for webhook URL is 255.  More resources: - [Configuring a webhook to send notifications when someone joins your video calls](https://www.daily.co/blog/configure-a-webhook-to-send-notifications-when-someone-joins-your-video-calls/)
    attr_accessor :meeting_join_hook

    # Daily uses signaling servers to manage all of the participants in a given call session. In an SFU/server mode call, the server will send and receive all audio and video from each participant. In a peer-to-peer call, each participant sends media directly to and from each other peer, but a signaling server still manages call state.  Daily runs servers in several different AWS regions to minimize latency for users around the world. The job of 'picking' a call server is handled when the first participant joins a room. The first participant's browser connects to a call server using Amazon's Route 53 DNS resolution, which chooses a server in the region closest to them.  This isn't always optimal. For example, if one person joins in London, and then ten more people join from Cape Town, the call will still be hosted out of `eu-west-2` . The majority of the participants will have higher latency to the server than if one of them had joined first and the call was being hosted in `af-south-1`. In cases like this, you may want to configure your domain (or a specific room) to always choose a call server in a specific AWS region.  Available regions: - `\"af-south-1\"` (Cape Town) - `\"ap-northeast-2\"` (Seoul) - `\"ap-southeast-1\"` (Singapore) - `\"ap-southeast-2\"` (Sydney) - `\"ap-south-1\"` (Mumbai) - `\"eu-central-1\"` (Frankfurt) - `\"eu-west-2\"` (London) - `\"sa-east-1\"` (São Paulo) - `\"us-east-1\"` (N. Virginia) - `\"us-west-2\"` (Oregon)
    attr_accessor :geo

    # Used to select the region where an RTMP stream should originate. In cases where RTMP streaming services aren't available in the desired region, we'll attempt to fall back to the default region based on the SFU being used for the meeting.    Available regions:   - `\"us-west-2\"` (Oregon)   - `\"eu-central-1\"` (Frankfurt)   - `\"ap-south-1\"` (Mumbai)    The default regions are grouped based on the SFU region like so:   - RTMP region `\"us-west-2\"` includes SFU regions: `\"us-west-2\"`, `\"us-east-1\"`, `\"sa-east-1\"`   - RTMP region `\"eu-central-1\"` includes SFU regions: `\"eu-central-1\"`, `\"eu-west-2\"`, `\"af-south-1\"`   - RTMP region `\"ap-south-1\"` includes SFU regions: `\"ap-southeast-1\"`, `\"ap-southeast-2\"`, `\"ap-northeast-2\"`, `\"ap-south-1\"`
    attr_accessor :rtmp_geo

    # Disable the fall back behavior of rtmp_geo. When rtmp_geo is set, we first try to connect to a media server in desired region. If a media server is not available in the desired region, we fall back to default region based on SFU's region. This property disables this automatic fall back. When this property is set, we will trigger a recording/streaming error event when media worker is unavailable. Also, the client should retry recording/streaming.
    attr_accessor :disable_rtmp_geo_fallback

    attr_accessor :recordings_bucket

    # Reduces the volume of log messages. This feature should be enabled when there are more than 200 participants in a meeting to help improve performance.  See our [guides for supporting large experiences](/guides/scaling-calls) for additional instruction.
    attr_accessor :enable_terse_logging

    # Options to use when `auto_start_transcription` is true. See [`startTranscription()`](/reference/daily-js/instance-methods/start-transcription) for available options.
    attr_accessor :auto_transcription_settings

    # Live transcriptions generated can be saved as WebVTT. This flag controls if transcription started with [`startTranscription()`](/reference/daily-js/instance-methods/start-transcription) should be saved or not.
    attr_accessor :enable_transcription_storage

    attr_accessor :transcription_bucket

    # Cloud recordings are stored in either Daily's S3 bucket or the customer's own S3 bucket. By default recordings are stored as `{domain_name}/{room_name}/{epoch_time}`. Sometimes, the use case may call for custom recording file names to be used (for example, if you'd like to enforce the presence of the .mp4 extension in the file name).  `recordings_template` is made up of a replacement string with prefixes, suffixes, or both. The currently supported replacements are:   - `epoch_time`: The epoch time in seconds (mandatory)   - `domain_name`: Your Daily domain (optional)   - `room_name`: The name of the room which is getting recorded (optional)   - `mtg_session_id`: The ID of the meeting session which is getting recorded (optional)   - `instance_id`: The instance ID of the recording (optional)   - `recording_id`: The recording ID of the recording (optional)    The restrictions for defining a recording template are as follows:   - The `epoch_time` tag is mandatory to ensure the recording file name is unique under all conditions   - The maximum size of the template is 1024 characters   - Each replacement parameter should be placed within a curly bracket (e.g., `{domain_name}`)   - Only alphanumeric characters `(0-9, A-Z, a-z)` and `.`, `/`, `-`, `_` are valid within the template   - `.mp4` is the only valid extension  Examples - Example domain: \"myDomain\" - Example room: \"myRoom\"  Example 1: - Template: `myprefix-{domain_name}-{epoch_time}.mp4` - Resulting file name: `myprefix-myDomain-1675842936274.mp4`  Example 2: - Template: `{room_name}/{instance_id}/{epoch_time}` - Resulting room name: `myRoom/d529cd2f-fbcc-4fb7-b2c0-c4995b1162b6/1675842936274`
    attr_accessor :recordings_template

    # An array of stream endpoint configuration objects, which allows configurations to be pre-defined without having to pass them into [`startLiveStreaming()`](/reference/daily-js/instance-methods/start-live-streaming) at runtime. For example, an RTMP endpoint can be set up for YouTube as a `streaming_endpoints` configuration along with another configuration for HLS storage.  HLS output can only be stored on a customer's S3, not in Daily's storage infrastructure. The stream configuration defines which S3 bucket to store the HLS output. (See the [S3 bucket guide](/guides/products/live-streaming-recording/storing-recordings-in-a-custom-s3-bucket) for more information.)  Example:  ```json  {   \"properties\": {     // ... add additional room properties here     \"streaming_endpoints\": [       {         \"name\": \"rtmp_youtube\",         \"type\": \"rtmp\",         \"rtmp_config\": {           \"url\": \"rtmps://exampleYouTubeServer.com:443/stream\"         }       },        {         \"name\": \"rtmp_ivs\",         \"type\": \"rtmp\",         \"rtmp_config\": {           \"url\": \"rtmps://811111111111.global-contribute.live-video.net:443/app/\"         }       },        {         \"name\": \"hls_akamai\",         \"type\": \"hls\",         \"hls_config\": {         \"save_hls_recording\": true/false,           \"storage\": {             \"bucket_name\": \"daily-hls-streams\",             \"bucket_region\": \"us-west-2\",             \"assume_role_arn\": \"arn:aws:iam::999999999999:role/DailyS3AccessRole\",             \"path_template\": \"testHarness/{live_streaming_id}/{instance_id}\"           },           \"variant\" : [               {                 \"width\": 1920,                 \"height\": 1080,                 \"fps\": 30,                 \"bitrate\": 3500,                 \"iframe_only\": false               },               {                 \"width\": 1280,                 \"height\": 720,                 \"fps\": 30,                 \"bitrate\": 2500,                 \"iframe_only\": false               },               {                 \"width\": 640,                 \"height\": 360,                 \"fps\": 30,                 \"bitrate\": 780,                 \"iframe_only\": true               }           ]         }       }     ]   } } ```  To reset the `streaming_endpoints` property, pass `null` instead of an array.  When calling `startLiveStreaming()`, the pre-defined `streaming_endpoints` `name` can be used:  ```javascript await callObject.startLiveStreaming({   endpoints: [{\"endpoint\":\"rtmp_youtube\"},{\"endpoint\":\"rtmp_fb\"}],   width: 1280,   height: 720, }); ``` Properties:
    attr_accessor :streaming_endpoints

    attr_accessor :permissions

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'nbf' => :'nbf',
        :'exp' => :'exp',
        :'max_participants' => :'max_participants',
        :'enable_people_ui' => :'enable_people_ui',
        :'enable_pip_ui' => :'enable_pip_ui',
        :'enable_emoji_reactions' => :'enable_emoji_reactions',
        :'enable_hand_raising' => :'enable_hand_raising',
        :'enable_prejoin_ui' => :'enable_prejoin_ui',
        :'enable_network_ui' => :'enable_network_ui',
        :'enable_noise_cancellation_ui' => :'enable_noise_cancellation_ui',
        :'enable_breakout_rooms' => :'enable_breakout_rooms',
        :'enable_knocking' => :'enable_knocking',
        :'enable_screenshare' => :'enable_screenshare',
        :'enable_video_processing_ui' => :'enable_video_processing_ui',
        :'enable_chat' => :'enable_chat',
        :'start_video_off' => :'start_video_off',
        :'start_audio_off' => :'start_audio_off',
        :'owner_only_broadcast' => :'owner_only_broadcast',
        :'enable_recording' => :'enable_recording',
        :'eject_at_room_exp' => :'eject_at_room_exp',
        :'eject_after_elapsed' => :'eject_after_elapsed',
        :'enable_advanced_chat' => :'enable_advanced_chat',
        :'enable_hidden_participants' => :'enable_hidden_participants',
        :'enable_mesh_sfu' => :'enable_mesh_sfu',
        :'sfu_switchover' => :'sfu_switchover',
        :'experimental_optimize_large_calls' => :'experimental_optimize_large_calls',
        :'lang' => :'lang',
        :'meeting_join_hook' => :'meeting_join_hook',
        :'geo' => :'geo',
        :'rtmp_geo' => :'rtmp_geo',
        :'disable_rtmp_geo_fallback' => :'disable_rtmp_geo_fallback',
        :'recordings_bucket' => :'recordings_bucket',
        :'enable_terse_logging' => :'enable_terse_logging',
        :'auto_transcription_settings' => :'auto_transcription_settings',
        :'enable_transcription_storage' => :'enable_transcription_storage',
        :'transcription_bucket' => :'transcription_bucket',
        :'recordings_template' => :'recordings_template',
        :'streaming_endpoints' => :'streaming_endpoints',
        :'permissions' => :'permissions'
      }
    end

    # Returns all the JSON keys this model knows about
    def self.acceptable_attributes
      attribute_map.values
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'nbf' => :'Integer',
        :'exp' => :'Integer',
        :'max_participants' => :'Integer',
        :'enable_people_ui' => :'Boolean',
        :'enable_pip_ui' => :'Boolean',
        :'enable_emoji_reactions' => :'Boolean',
        :'enable_hand_raising' => :'Boolean',
        :'enable_prejoin_ui' => :'Boolean',
        :'enable_network_ui' => :'Boolean',
        :'enable_noise_cancellation_ui' => :'Boolean',
        :'enable_breakout_rooms' => :'Boolean',
        :'enable_knocking' => :'Boolean',
        :'enable_screenshare' => :'Boolean',
        :'enable_video_processing_ui' => :'Boolean',
        :'enable_chat' => :'Boolean',
        :'start_video_off' => :'Boolean',
        :'start_audio_off' => :'Boolean',
        :'owner_only_broadcast' => :'Boolean',
        :'enable_recording' => :'String',
        :'eject_at_room_exp' => :'Boolean',
        :'eject_after_elapsed' => :'Integer',
        :'enable_advanced_chat' => :'Boolean',
        :'enable_hidden_participants' => :'Boolean',
        :'enable_mesh_sfu' => :'Boolean',
        :'sfu_switchover' => :'Float',
        :'experimental_optimize_large_calls' => :'Boolean',
        :'lang' => :'String',
        :'meeting_join_hook' => :'String',
        :'geo' => :'String',
        :'rtmp_geo' => :'String',
        :'disable_rtmp_geo_fallback' => :'Boolean',
        :'recordings_bucket' => :'RecordingsBucket',
        :'enable_terse_logging' => :'Boolean',
        :'auto_transcription_settings' => :'Object',
        :'enable_transcription_storage' => :'Boolean',
        :'transcription_bucket' => :'TranscriptionBucket',
        :'recordings_template' => :'String',
        :'streaming_endpoints' => :'Array<RoomPropertiesStreamingEndpointsInner>',
        :'permissions' => :'Permissions'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `Daily::RoomProperties` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `Daily::RoomProperties`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'nbf')
        self.nbf = attributes[:'nbf']
      end

      if attributes.key?(:'exp')
        self.exp = attributes[:'exp']
      end

      if attributes.key?(:'max_participants')
        self.max_participants = attributes[:'max_participants']
      else
        self.max_participants = 200
      end

      if attributes.key?(:'enable_people_ui')
        self.enable_people_ui = attributes[:'enable_people_ui']
      end

      if attributes.key?(:'enable_pip_ui')
        self.enable_pip_ui = attributes[:'enable_pip_ui']
      end

      if attributes.key?(:'enable_emoji_reactions')
        self.enable_emoji_reactions = attributes[:'enable_emoji_reactions']
      end

      if attributes.key?(:'enable_hand_raising')
        self.enable_hand_raising = attributes[:'enable_hand_raising']
      end

      if attributes.key?(:'enable_prejoin_ui')
        self.enable_prejoin_ui = attributes[:'enable_prejoin_ui']
      end

      if attributes.key?(:'enable_network_ui')
        self.enable_network_ui = attributes[:'enable_network_ui']
      end

      if attributes.key?(:'enable_noise_cancellation_ui')
        self.enable_noise_cancellation_ui = attributes[:'enable_noise_cancellation_ui']
      end

      if attributes.key?(:'enable_breakout_rooms')
        self.enable_breakout_rooms = attributes[:'enable_breakout_rooms']
      end

      if attributes.key?(:'enable_knocking')
        self.enable_knocking = attributes[:'enable_knocking']
      end

      if attributes.key?(:'enable_screenshare')
        self.enable_screenshare = attributes[:'enable_screenshare']
      else
        self.enable_screenshare = true
      end

      if attributes.key?(:'enable_video_processing_ui')
        self.enable_video_processing_ui = attributes[:'enable_video_processing_ui']
      else
        self.enable_video_processing_ui = true
      end

      if attributes.key?(:'enable_chat')
        self.enable_chat = attributes[:'enable_chat']
      else
        self.enable_chat = false
      end

      if attributes.key?(:'start_video_off')
        self.start_video_off = attributes[:'start_video_off']
      else
        self.start_video_off = false
      end

      if attributes.key?(:'start_audio_off')
        self.start_audio_off = attributes[:'start_audio_off']
      else
        self.start_audio_off = false
      end

      if attributes.key?(:'owner_only_broadcast')
        self.owner_only_broadcast = attributes[:'owner_only_broadcast']
      else
        self.owner_only_broadcast = false
      end

      if attributes.key?(:'enable_recording')
        self.enable_recording = attributes[:'enable_recording']
      else
        self.enable_recording = '<not set>'
      end

      if attributes.key?(:'eject_at_room_exp')
        self.eject_at_room_exp = attributes[:'eject_at_room_exp']
      else
        self.eject_at_room_exp = false
      end

      if attributes.key?(:'eject_after_elapsed')
        self.eject_after_elapsed = attributes[:'eject_after_elapsed']
      end

      if attributes.key?(:'enable_advanced_chat')
        self.enable_advanced_chat = attributes[:'enable_advanced_chat']
      else
        self.enable_advanced_chat = false
      end

      if attributes.key?(:'enable_hidden_participants')
        self.enable_hidden_participants = attributes[:'enable_hidden_participants']
      else
        self.enable_hidden_participants = false
      end

      if attributes.key?(:'enable_mesh_sfu')
        self.enable_mesh_sfu = attributes[:'enable_mesh_sfu']
      end

      if attributes.key?(:'sfu_switchover')
        self.sfu_switchover = attributes[:'sfu_switchover']
      else
        self.sfu_switchover = 2
      end

      if attributes.key?(:'experimental_optimize_large_calls')
        self.experimental_optimize_large_calls = attributes[:'experimental_optimize_large_calls']
      end

      if attributes.key?(:'lang')
        self.lang = attributes[:'lang']
      else
        self.lang = 'en'
      end

      if attributes.key?(:'meeting_join_hook')
        self.meeting_join_hook = attributes[:'meeting_join_hook']
      end

      if attributes.key?(:'geo')
        self.geo = attributes[:'geo']
      else
        self.geo = 'NULL'
      end

      if attributes.key?(:'rtmp_geo')
        self.rtmp_geo = attributes[:'rtmp_geo']
      else
        self.rtmp_geo = 'The closest available region to the SFU region used by the meeting.'
      end

      if attributes.key?(:'disable_rtmp_geo_fallback')
        self.disable_rtmp_geo_fallback = attributes[:'disable_rtmp_geo_fallback']
      else
        self.disable_rtmp_geo_fallback = false
      end

      if attributes.key?(:'recordings_bucket')
        self.recordings_bucket = attributes[:'recordings_bucket']
      end

      if attributes.key?(:'enable_terse_logging')
        self.enable_terse_logging = attributes[:'enable_terse_logging']
      else
        self.enable_terse_logging = false
      end

      if attributes.key?(:'auto_transcription_settings')
        self.auto_transcription_settings = attributes[:'auto_transcription_settings']
      end

      if attributes.key?(:'enable_transcription_storage')
        self.enable_transcription_storage = attributes[:'enable_transcription_storage']
      else
        self.enable_transcription_storage = false
      end

      if attributes.key?(:'transcription_bucket')
        self.transcription_bucket = attributes[:'transcription_bucket']
      end

      if attributes.key?(:'recordings_template')
        self.recordings_template = attributes[:'recordings_template']
      else
        self.recordings_template = '{domain_name}/{room_name}/{epoch_time}.'
      end

      if attributes.key?(:'streaming_endpoints')
        if (value = attributes[:'streaming_endpoints']).is_a?(Array)
          self.streaming_endpoints = value
        end
      end

      if attributes.key?(:'permissions')
        self.permissions = attributes[:'permissions']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      warn '[DEPRECATED] the `valid?` method is obsolete'
      enable_recording_validator = EnumAttributeValidator.new('String', ["cloud", "local", "raw-tracks", "<not set>"])
      return false unless enable_recording_validator.valid?(@enable_recording)
      lang_validator = EnumAttributeValidator.new('String', ["de", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pt", "pt-BR", "pl", "ru", "sv", "tr", "user"])
      return false unless lang_validator.valid?(@lang)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] enable_recording Object to be assigned
    def enable_recording=(enable_recording)
      validator = EnumAttributeValidator.new('String', ["cloud", "local", "raw-tracks", "<not set>"])
      unless validator.valid?(enable_recording)
        fail ArgumentError, "invalid value for \"enable_recording\", must be one of #{validator.allowable_values}."
      end
      @enable_recording = enable_recording
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] lang Object to be assigned
    def lang=(lang)
      validator = EnumAttributeValidator.new('String', ["de", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pt", "pt-BR", "pl", "ru", "sv", "tr", "user"])
      unless validator.valid?(lang)
        fail ArgumentError, "invalid value for \"lang\", must be one of #{validator.allowable_values}."
      end
      @lang = lang
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          nbf == o.nbf &&
          exp == o.exp &&
          max_participants == o.max_participants &&
          enable_people_ui == o.enable_people_ui &&
          enable_pip_ui == o.enable_pip_ui &&
          enable_emoji_reactions == o.enable_emoji_reactions &&
          enable_hand_raising == o.enable_hand_raising &&
          enable_prejoin_ui == o.enable_prejoin_ui &&
          enable_network_ui == o.enable_network_ui &&
          enable_noise_cancellation_ui == o.enable_noise_cancellation_ui &&
          enable_breakout_rooms == o.enable_breakout_rooms &&
          enable_knocking == o.enable_knocking &&
          enable_screenshare == o.enable_screenshare &&
          enable_video_processing_ui == o.enable_video_processing_ui &&
          enable_chat == o.enable_chat &&
          start_video_off == o.start_video_off &&
          start_audio_off == o.start_audio_off &&
          owner_only_broadcast == o.owner_only_broadcast &&
          enable_recording == o.enable_recording &&
          eject_at_room_exp == o.eject_at_room_exp &&
          eject_after_elapsed == o.eject_after_elapsed &&
          enable_advanced_chat == o.enable_advanced_chat &&
          enable_hidden_participants == o.enable_hidden_participants &&
          enable_mesh_sfu == o.enable_mesh_sfu &&
          sfu_switchover == o.sfu_switchover &&
          experimental_optimize_large_calls == o.experimental_optimize_large_calls &&
          lang == o.lang &&
          meeting_join_hook == o.meeting_join_hook &&
          geo == o.geo &&
          rtmp_geo == o.rtmp_geo &&
          disable_rtmp_geo_fallback == o.disable_rtmp_geo_fallback &&
          recordings_bucket == o.recordings_bucket &&
          enable_terse_logging == o.enable_terse_logging &&
          auto_transcription_settings == o.auto_transcription_settings &&
          enable_transcription_storage == o.enable_transcription_storage &&
          transcription_bucket == o.transcription_bucket &&
          recordings_template == o.recordings_template &&
          streaming_endpoints == o.streaming_endpoints &&
          permissions == o.permissions
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [nbf, exp, max_participants, enable_people_ui, enable_pip_ui, enable_emoji_reactions, enable_hand_raising, enable_prejoin_ui, enable_network_ui, enable_noise_cancellation_ui, enable_breakout_rooms, enable_knocking, enable_screenshare, enable_video_processing_ui, enable_chat, start_video_off, start_audio_off, owner_only_broadcast, enable_recording, eject_at_room_exp, eject_after_elapsed, enable_advanced_chat, enable_hidden_participants, enable_mesh_sfu, sfu_switchover, experimental_optimize_large_calls, lang, meeting_join_hook, geo, rtmp_geo, disable_rtmp_geo_fallback, recordings_bucket, enable_terse_logging, auto_transcription_settings, enable_transcription_storage, transcription_bucket, recordings_template, streaming_endpoints, permissions].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      attributes = attributes.transform_keys(&:to_sym)
      transformed_hash = {}
      openapi_types.each_pair do |key, type|
        if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = nil
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[attribute_map[key]].is_a?(Array)
            transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
          end
        elsif !attributes[attribute_map[key]].nil?
          transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
        end
      end
      new(transformed_hash)
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def self._deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = Daily.const_get(type)
        klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
