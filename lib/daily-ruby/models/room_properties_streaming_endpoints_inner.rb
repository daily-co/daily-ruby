# =begin
# #Daily API

# #The Daily REST API offers the ability to manage the following:  - Overall Domain Configuration - Individual Room creation and config management  - Meeting token creation and validation - Recording and compositing management  - Meeting analytics - Logs and metrics - Real-time presence  Please reach out to help@daily.co if we can help with anything

# The version of the OpenAPI document: 1.1.1
# Contact: help@daily.co
# Generated by: https://openapi-generator.tech
# OpenAPI Generator version: 7.3.0

# =end

# require 'date'
# require 'time'

# module Daily
#   class RoomPropertiesStreamingEndpointsInner
#     # Used by the `startLiveStreaming()` API to reference which stream configuration to start.
#     attr_accessor :name

#     # Whether the streaming endpoint is `rtmp` or `hls`.
#     attr_accessor :type

#     # The `s3Key` path prefix for where to store the recordings. Therefore, the final final master.m3u8 path template is `<bucket_name>/<path>/<mtgSessionId>/master.m3u8`, i.e. `hls_config['storage']['bucket_name']/hls_config['storage']['path']/<mtgSessionId>/master.m3u8`.
#     attr_accessor :hls_config_storage_path

#     # `path_template` is made up of a replacement string with prefixes, suffixes, or both. `path_template` without replacement string is also valid. The currently supported replacements are:   - `epoch_time`: The epoch time in seconds (optional)   - `domain_name`: Your Daily domain (optional)   - `room_name`: The name of the room which is getting recorded (optional)   - `mtg_session_id`: The ID of the meeting session which is getting recorded (optional)   - `instance_id`: The instance ID of the recording (optional)   - `live_streaming_id`: The ID of the live streaming in our DB (optional)    The restrictions for defining a recording template are as follows:   - The maximum size of the template is 1024 characters   - Each replacement parameter should be placed within a curly bracket (e.g., `{domain_name}`)   - Only alphanumeric characters `(0-9, A-Z, a-z)` and `.`, `/`, `-`, `_` are valid within the template  Examples - Example domain: \"myDomain\" - Example room: \"myRoom\" - example hls bucket: \"HLS_S3_BUCKET\"  Example 1: - Template: `my-hls-{domain_name}-{epoch_time}` - Resulting path of master.m3u8: `s3://HLS_S3_BUCKET/my-hls-myDomain-1675842936274/master.m3u8`  Example 2: - Template: `{room_name}/{instance_id}/` - Resulting path of master.m3u8: `myRoom/d529cd2f-fbcc-4fb7-b2c0-c4995b1162b6/master.m3u8`
#     attr_accessor :hls_config_storage_path_template

#     # If `true`, the live stream will be saved as a recording after streaming has ended. If `false`, the stream is available only until the streaming is live.
#     attr_accessor :hls_config_save_hls_recording

#     # An optional array of variants to generate for HLS. For most use cases this property can be omitted as Daily uses sensible defaults. The array defines the resolution, FPS, and bitrate for each variant. The following limitations apply:  - There can be a maximum of one variant with 1080p resolution. All other variants must be less than or equal to 720p. - A maximum of four variants can be specified, other than iframe-only stream - We do not support iframe-only variant, at least one full-stream variant is required
#     attr_accessor :hls_config_variants

#     # Attribute mapping from ruby-style variable name to JSON key.
#     def self.attribute_map
#       {
#         :'name' => :'name',
#         :'type' => :'type',
#         :'hls_config_storage_path' => :'hls_config['storage']['path']',
#         :'hls_config_storage_path_template' => :'hls_config['storage']['path_template']',
#         :'hls_config_save_hls_recording' => :'hls_config['save_hls_recording']',
#         :'hls_config_variants' => :'hls_config['variants']'
#       }
#     end

#     # Returns all the JSON keys this model knows about
#     def self.acceptable_attributes
#       attribute_map.values
#     end

#     # Attribute type mapping.
#     def self.openapi_types
#       {
#         :'name' => :'String',
#         :'type' => :'String',
#         :'hls_config_storage_path' => :'String',
#         :'hls_config_storage_path_template' => :'String',
#         :'hls_config_save_hls_recording' => :'Boolean',
#         :'hls_config_variants' => :'Array<RoomPropertiesStreamingEndpointsInnerHlsConfigVariantsInner>'
#       }
#     end

#     # List of attributes with nullable: true
#     def self.openapi_nullable
#       Set.new([
#       ])
#     end

#     # Initializes the object
#     # @param [Hash] attributes Model attributes in the form of hash
#     def initialize(attributes = {})
#       if (!attributes.is_a?(Hash))
#         fail ArgumentError, "The input argument (attributes) must be a hash in `Daily::RoomPropertiesStreamingEndpointsInner` initialize method"
#       end

#       # check to see if the attribute exists and convert string to symbol for hash key
#       attributes = attributes.each_with_object({}) { |(k, v), h|
#         if (!self.class.attribute_map.key?(k.to_sym))
#           fail ArgumentError, "`#{k}` is not a valid attribute in `Daily::RoomPropertiesStreamingEndpointsInner`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
#         end
#         h[k.to_sym] = v
#       }

#       if attributes.key?(:'name')
#         self.name = attributes[:'name']
#       end

#       if attributes.key?(:'type')
#         self.type = attributes[:'type']
#       end

#       if attributes.key?(:'hls_config_storage_path')
#         self.hls_config_storage_path = attributes[:'hls_config_storage_path']
#       end

#       if attributes.key?(:'hls_config_storage_path_template')
#         self.hls_config_storage_path_template = attributes[:'hls_config_storage_path_template']
#       end

#       if attributes.key?(:'hls_config_save_hls_recording')
#         self.hls_config_save_hls_recording = attributes[:'hls_config_save_hls_recording']
#       end

#       if attributes.key?(:'hls_config_variants')
#         if (value = attributes[:'hls_config_variants']).is_a?(Array)
#           self.hls_config_variants = value
#         end
#       end
#     end

#     # Show invalid properties with the reasons. Usually used together with valid?
#     # @return Array for valid properties with the reasons
#     def list_invalid_properties
#       warn '[DEPRECATED] the `list_invalid_properties` method is obsolete'
#       invalid_properties = Array.new
#       invalid_properties
#     end

#     # Check to see if the all the properties in the model are valid
#     # @return true if the model is valid
#     def valid?
#       warn '[DEPRECATED] the `valid?` method is obsolete'
#       true
#     end

#     # Checks equality by comparing each attribute.
#     # @param [Object] Object to be compared
#     def ==(o)
#       return true if self.equal?(o)
#       self.class == o.class &&
#           name == o.name &&
#           type == o.type &&
#           hls_config_storage_path == o.hls_config_storage_path &&
#           hls_config_storage_path_template == o.hls_config_storage_path_template &&
#           hls_config_save_hls_recording == o.hls_config_save_hls_recording &&
#           hls_config_variants == o.hls_config_variants
#     end

#     # @see the `==` method
#     # @param [Object] Object to be compared
#     def eql?(o)
#       self == o
#     end

#     # Calculates hash code according to all attributes.
#     # @return [Integer] Hash code
#     def hash
#       [name, type, hls_config_storage_path, hls_config_storage_path_template, hls_config_save_hls_recording, hls_config_variants].hash
#     end

#     # Builds the object from hash
#     # @param [Hash] attributes Model attributes in the form of hash
#     # @return [Object] Returns the model itself
#     def self.build_from_hash(attributes)
#       return nil unless attributes.is_a?(Hash)
#       attributes = attributes.transform_keys(&:to_sym)
#       transformed_hash = {}
#       openapi_types.each_pair do |key, type|
#         if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
#           transformed_hash["#{key}"] = nil
#         elsif type =~ /\AArray<(.*)>/i
#           # check to ensure the input is an array given that the attribute
#           # is documented as an array but the input is not
#           if attributes[attribute_map[key]].is_a?(Array)
#             transformed_hash["#{key}"] = attributes[attribute_map[key]].map { |v| _deserialize($1, v) }
#           end
#         elsif !attributes[attribute_map[key]].nil?
#           transformed_hash["#{key}"] = _deserialize(type, attributes[attribute_map[key]])
#         end
#       end
#       new(transformed_hash)
#     end

#     # Deserializes the data based on type
#     # @param string type Data type
#     # @param string value Value to be deserialized
#     # @return [Object] Deserialized data
#     def self._deserialize(type, value)
#       case type.to_sym
#       when :Time
#         Time.parse(value)
#       when :Date
#         Date.parse(value)
#       when :String
#         value.to_s
#       when :Integer
#         value.to_i
#       when :Float
#         value.to_f
#       when :Boolean
#         if value.to_s =~ /\A(true|t|yes|y|1)\z/i
#           true
#         else
#           false
#         end
#       when :Object
#         # generic object (usually a Hash), return directly
#         value
#       when /\AArray<(?<inner_type>.+)>\z/
#         inner_type = Regexp.last_match[:inner_type]
#         value.map { |v| _deserialize(inner_type, v) }
#       when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
#         k_type = Regexp.last_match[:k_type]
#         v_type = Regexp.last_match[:v_type]
#         {}.tap do |hash|
#           value.each do |k, v|
#             hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
#           end
#         end
#       else # model
#         # models (e.g. Pet) or oneOf
#         klass = Daily.const_get(type)
#         klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
#       end
#     end

#     # Returns the string representation of the object
#     # @return [String] String presentation of the object
#     def to_s
#       to_hash.to_s
#     end

#     # to_body is an alias to to_hash (backward compatibility)
#     # @return [Hash] Returns the object in the form of hash
#     def to_body
#       to_hash
#     end

#     # Returns the object in the form of hash
#     # @return [Hash] Returns the object in the form of hash
#     def to_hash
#       hash = {}
#       self.class.attribute_map.each_pair do |attr, param|
#         value = self.send(attr)
#         if value.nil?
#           is_nullable = self.class.openapi_nullable.include?(attr)
#           next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
#         end

#         hash[param] = _to_hash(value)
#       end
#       hash
#     end

#     # Outputs non-array value in the form of hash
#     # For object, use to_hash. Otherwise, just return the value
#     # @param [Object] value Any valid value
#     # @return [Hash] Returns the value in the form of hash
#     def _to_hash(value)
#       if value.is_a?(Array)
#         value.compact.map { |v| _to_hash(v) }
#       elsif value.is_a?(Hash)
#         {}.tap do |hash|
#           value.each { |k, v| hash[k] = _to_hash(v) }
#         end
#       elsif value.respond_to? :to_hash
#         value.to_hash
#       else
#         value
#       end
#     end

#   end

# end
